20201010
1. boost::recursive_mutex
2. invalid initialization of non-const reference of type int& from an rvalue of type int
    1. 非const引用不能绑定一个右值，例如
        ```
        int& a = 3 + 5;         // 不正确，不能绑定到一个右值上，因为无法确保后期不会修改这个变量，而这个变量却是常量
        const int& a = 3 + 5;   // 正确
        ```
        
20201012
1. mutable 是可变的，易变的。用它来修饰变量，意味着该变量可以被修改，即使该变量所在的成员被const限定。mutable是用来突破const限定的。
2.  [tutorial](https://www.boost.org/doc/libs/1_74_0/doc/html/thread/synchronization.html#thread.synchronization.mutex_types)
    ```
    typedef boost::recursive_mutex  RecMutex;                   // 互斥量
    typedef boost::recursive_mutex::scoped_lock RecLock;        // 锁
    // RecLock用RecMutex来初始化
    ```
    ```
    boost::lock_guard
    ```
3. 用make来编译，而不是手动的用g++来编译，这样会很方便：[makefile 学习](https://blog.csdn.net/wcl199274/article/details/39140459?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

















































